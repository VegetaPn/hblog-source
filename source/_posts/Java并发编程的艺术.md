---
title: [Note] Java 并发编程的艺术
date: 2019-07-23 00:04:13
tags: Java
categories: Tech
---

# [Note] Java 并发编程的艺术

原子性

32位处理器：
通过总线锁或对缓存加锁的方式

总线锁：处理器在总线上输出 #LOCK 信号
缓存锁：“缓存锁定”

Java：
通过锁和循环CAS的方式

循环CAS：循环进行CAS直到成功为止
问题解决：
ABA问题：加入版本号 AutomicStampedReference
循环时间开销大：JVM支持CPU提供的pause指令
只能保证一个共享变量的原子操作：使用锁；将多个共享变量合为一个变量；AutomicReference

锁机制：偏向锁、轻量级锁、互斥所


## 内存模型

线程之间的通信机制：共享内存、消息传递

Java的并发采用共享内存模型

JMM (Java内存模型) 控制线程之间的通信，定义了线程与主内存之间的通信
线程之间的共享变量存储在主内存中
每个线程都有一个私有的本地内存，存储了该线程以读写共享变量的副本

线程A更新本地内存 --> 线程A刷主内存 --> 线程B读取主内存 --> 线程B更新本地内存


重排序的3种类型
1. 编译器优化的重排序
2. 指令级并行的重排序
3. 内存系统的重排序


**happens-before**

前一个操作执行的结果对后一个操作可见，且前一个操作按顺序排在第二个操作之前
不一位置前一个操作必须在后一个操作之前执行

- 程序顺序规则
- 监视器锁规则
- volatile变量规则
- 传递性

**数据依赖性**

- 写后读
- 写后写
- 读后写

**as-if-serial**

不管怎么重排序，单线程程序的执行结果不能被改变

**猜测执行**

在多线程中，对存在控制依赖的操作重排序，可能会改变程序的运行结果


### 顺序一致性

**数据竞争**

**顺序一致性内存模型**

理想的一致性内存模型

1. 一个线程中的所有操作必须按照程序的顺序来执行
2. 所有线程都只能看到一个单一的操作执行顺序。每个操作都必须原子执行且立刻对所有线程可见

JMM中没有这个保证

在JMM中，临界区内的代码可以重排序

在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门

**未同步程序的执行特性**

- 单线程内的操作不保证按程序的顺序执行
- 不保证所有线程能看到一致的操作执行顺序
- 不保证对64位的long型和double型变量的写操作具有原子性
  - 性能考虑，JVM可能拆分为两个32位的写操作来进行

总线会同步试图并发使用总线的事务

### volatile的内存语义

对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步
volatile++不具有原子性

volatile变量的特性
- 可见性
- 原子性

volatile的写-读可以实现线程间的通信

**volatile写的内存语义**

当写一个volatile变量时，JMM会把该线程对应的本地内存中对应的共享变量值刷新到主内存

**volatile读的内存语义**

当读一个volatile变量时，JMM会把该线程对应的本地内存置位无效。线程接下来将从主内存中读取共享变量

**volatile内存语义的实现**

JMM会分别限制编译器重排序和处理器重排序

针对编译器制定的重排序规则：
- 当第二个操作是volatile写，不管第一个操作是什么，都不能重排序。确保volatile写之前的操作不会被重排序到volatile写之后
- 当第一个操作是volatile读，不管第二个操作是什么，都不能重排序。确保volatile读之后的操作不会被重排序到volatile读之前
- 当第一个操作时volatile写，第二个操作是volatile读时，不能重排序

生成字节码时，编译器会插入内存屏障来禁止特定类型的处理器重排序：
- 在每个volatile写操作的前面插入一个StoreStore屏障
- 在每个volatile写操作的后面插入一个StoreLoad屏障
- 在每个volatile读操作的后面插入一个LoadLoad屏障
- 在每个volatile读操作的后面插入一个LoadStore屏障

编译器可以根据具体情况省略不必要的屏障

