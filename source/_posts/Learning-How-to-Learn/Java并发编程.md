
原子性

32位处理器：
通过总线锁或对缓存加锁的方式

总线锁：处理器在总线上输出 #LOCK 信号
缓存锁：“缓存锁定”

Java：
通过锁和循环CAS的方式

循环CAS：循环进行CAS直到成功为止
问题解决：
ABA问题：加入版本号 AutomicStampedReference
循环时间开销大：JVM支持CPU提供的pause指令
只能保证一个共享变量的原子操作：使用锁；将多个共享变量合为一个变量；AutomicReference

锁机制：偏向锁、轻量级锁、互斥所


## 内存模型

线程之间的通信机制：共享内存、消息传递

Java的并发采用共享内存模型

JMM (Java内存模型) 控制线程之间的通信，定义了线程与主内存之间的通信
线程之间的共享变量存储在主内存中
每个线程都有一个私有的本地内存，存储了该线程以读写共享变量的副本

线程A更新本地内存 --> 线程A刷主内存 --> 线程B读取主内存 --> 线程B更新本地内存


重排序的3种类型
1. 编译器优化的重排序
2. 指令级并行的重排序
3. 内存系统的重排序


**happens-before**

前一个操作执行的结果对后一个操作可见，且前一个操作按顺序排在第二个操作之前
不一位置前一个操作必须在后一个操作之前执行

- 程序顺序规则
- 监视器锁规则
- volatile变量规则
- 传递性

**数据依赖性**

- 写后读
- 写后写
- 读后写

**as-if-serial**

不管怎么重排序，单线程程序的执行结果不能被改变

**猜测执行**

在多线程中，对存在控制依赖的操作重排序，可能会改变程序的运行结果