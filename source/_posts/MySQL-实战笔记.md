---
title: MySQL 实战学习笔记  
tags: MySQL
categories: Tech
date: 2019-01-18 09:48:56  
---


# 01 概览  

## 概览
MySQL分为服务层和存储引擎层，服务层连接器、查询缓存、分析器、优化器、执行器等，包括内置功能函数（日期时间、数学、加密函数等），包括所有跨存储引擎的功能，比如存储过程、触发器、视图等。存储引擎负责数据的存储和提取。

MySQL 逻辑视图：
{% asset_img 01.png %}  
<!-- more -->
# 02 日志系统  

## redo log
> InnoDB特有的日志

WAL：Write-Ahead Logging，先写日志，再写磁盘  

当有一条记录需要更新的时候，InnoDB先把记录写到redo log，并更新内存，次数更新就算完成了。同时，InnoDB在适当的时候，将这个操作记录更新到磁盘，这个更新往往是在系统比较空闲的时候做  

InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小1GB。从头开始写，写到末尾就回到开头循环写。

{% asset_img 02.png %}

write pos是当前记录的位置，一边写一边后移，checkpoint是当前要擦除的位置，也是往后推移并循环的，擦除记录前把记录更新到数据文件  

write pos和checkpoint之间的是空着的部分，可以用来记录新的操作。如果write pos追上了checkpoint，则表示记录满了，不能在执行新的更新，此时需要擦除一些记录  

有了redo log，InnoDB就可以保证即时数据库异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe  

innode_flush_log_at_trx_commit参数，设置成1的时候，表示每次事物的redo log都直接持久化到磁盘

sync_binlog设置成1，表示每次事务的binlog都持久化到磁盘

## binlog
> server层自己的日志  

最开始的MySQL并没有INNODB引擎，自带引擎是MyISAM，没有crash-safe能力，binlog日志只用于归档

与redo log的区别
1. redo log是InnoDB特有的，binlog是MySQL的server层实现的，所有引擎都可以使用
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”
3. redo log是循环写的，空间固定会用完，binlog是可以追加写的，写到一定大小后会切换到下一个，不会覆盖以前的日志


在更新语句时的INNODB流程：
> update T set c=c+1 where ID=2;

1. 执行器先找引擎取ID=2这一行。先读内存，再度磁盘 
2. 执行器拿到行数据，将值加1，得到新数据，再调用引擎写入新数据
3. 引擎将新数据更新到内存，同时将更新记录记录到redo log，此时redo log为prepare状态。然后告知执行器执行完了，可以提交事务
4. 执行器生成这个操作的binlog，并把binlog写入磁盘
5. 执行器调用引擎的提交事务接口，把redo log状态更新为提交状态，更新完成02

{% asset_img 03.png %}

## 事务隔离

### 事务隔离级别

- read uncommitted 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到
- read committed 读提交：一个事务提交后，它做的变更才会被其他事务看到
- repeatable read 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。（未提交变更对其他事物也是不可见的）
- serializable 串行化：对于同一行记录，写会加写锁，读会加读锁，出现读写锁冲突时，后访问的事务必须等前一个事务执行完成才能继续执行

相关参数：transaction-isolation

### 事务隔离的实现

每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值

{% asset_img 04.png %}

当前值是4，但是在查询的时候，不同时刻启动的事务会有不同的read-view。在视图A B C里，这一个记录的值分别是1 2 4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

同时即使现在有另外一个事务正在将4改成5，这个事物跟read-view A B C对应的事务是不会冲突的

回滚日志在不需要的时候会被删除。即当系统里没有比这个回滚日志更早的read-view的时候

### 为什不不建议使用长事务

长事务意味着系统里会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面他可能用到的回滚记录都必须保留，这就会导致大量占用存储空间

长事务还会占用锁资源，也可能拖垮整个库

### 事务的启动方式

1 显示启动事务语句，begin或start transaction。配套的提交语句是commit，回滚语句是rollback
2 set autocommit = 0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到你主动执行commit或rollback语句，或者断开连接

可以在information_schema库的innodb_trx这个表中查询长事务

``` 
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

### 索引

每一个索引在INNODB里面对应一棵B+树

```
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

对应的索引结构：
{% asset_img 05.png %}

根据叶子节点的内容，索引类型分为主键索引和非主键索引

主键索引的叶子节点存的是整行数据。在INNODB，主键索引也被称为聚簇索引（clustered index）

非主键索引的叶子节点内容是主键的值。在INNODB，非主键索引也被称为二级索引（secondary index）

主键查询方式，只需要搜索ID这棵树

普通索引查询方式，需要先搜索k索引树，得到ID值，再到ID索引树搜索一次，这个过程成为回表

#### insert 流程  
{% asset_img 10.JPG %}

#### 索引选择错误
{% asset_img 11.JPG %}

#### 字符串 前缀索引
{% asset_img 12.JPG %}
{% asset_img 13.JPG %}

### 索引维护

以上面的图为例，如果插入的新的行ID值为700，在只需要在R5的记录后面插入一个新纪录。如果新插入的ID值为400，需要逻辑上挪动后面的数据，空出位置

如果R5所在的数据页已经满了，这个时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程成为页分裂

页分裂除了影响性能，还影响数据页的利用率

当相邻两个页由于删除了数据。原本放在一个页的数据，利用率很低之后，会将数据页做合并。（分裂过程的逆过程）

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。从性能和存储空间方面考量，自增主键往往是更合理的选择

### 覆盖索引

```
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

{% asset_img 06.png %}

如果执行的语句是 select * from T where k between 3 and 5

1. 在k索引树上找到k=3的记录，取的ID=300
2. 再到ID索引树上找到ID=300对应的R3
3. 在k索引树取下一个值k=5，取得ID=500
4. 再回到ID索引树查到ID=500对应的R4
5. 在k索引树取下一个值k=6，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，称为回表

如果执行的语句是 select ID from T where k between 3 and 5
这时只需要查ID的值，而ID的值已经在k索引树上了，因此不需要回表

也就是说，索引k已经覆盖了我们的查询需求，我们称为覆盖索引

覆盖索引可以减少树的搜索次数，显著提升查询性能

### 最左前缀原则

可以利用索引的“最左前缀”，来定位记录

{% asset_img 07.jpg %}

当查询所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果

当查询的是所有名字第一个字是“张”得人（where name like ’张%‘”。这时也可以用到这个索引

在建立联合索引时，如何安排索引的顺序：
- 索引的复用能力：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的

### 索引下推

MySQL 5.6 引入的优化，在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

联合索引（name, age）
```
mysql> select * from tuser where name like '张 %' and age=10 and ismale=1;
```

5.6之前：从ID3开始一个个回表，到主键索引上找出数据行，再对比字段值
5.6及之后：在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

无索引下推执行流程：
{% asset_img 08.jpg %}

有索引下推执行流程：
{% asset_img 09.jpg %}

## 锁

### 全局锁

对整个数据库实例加锁

Flush tables with read lock（FTWRL）：加全局读锁的方法，阻塞数据更新语句、数据定义语句、更新类事务的提交语句

### 表级锁

表级别的锁有两种：表锁、元数据锁

#### 表锁

lock tables ... read/write，可以用unlock tables主动释放锁，断开连接时自动释放

#### MDL 元数据锁

不需要显示使用，在访问一个表时自动加上

作用是保证读写的正确性，当对一个表做增删改查的时候，加MDL读锁，当对表结构做变更的时候，加MDL写锁

- 读锁之间不互斥，因此你可以有多个线程同时对一张表进行增删改查
- 读写锁之间、写锁之间互斥，保障变更表结构操作的安全性

### 行锁

两段锁协议：INNODB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放

当出现死锁后，有两种策略:
- 一种策略是，直接进入等待，直到超时
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行

正常和默认情况下采用第二种，但会带来性能损耗，每个新来的被堵住的线程，都需要发起死锁检测，需要消耗大量CPU资源。可以通过临时关闭检测或控制并发度来控制资源消耗

### 脏页 FLUSH

当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页就一致了，成为“干净页”

flush的时机

- redo log写满了
- 系统内存不足，当需要新的内存页，而内存不够的时候，需要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。这种情况是常态
- MySQL认为系统空闲的时候
- MySQL正常关闭的时候

InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态
- 还没有使用的
- 使用了并且是干净页
- 使用了并且是脏页

InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库，未被使用的页面很少

刷脏页虽然是常态，但是出现以下情况，会明显影响性能
- 一个查询要淘汰的脏页个数太多
- 日志写满，更新全部堵住，写性能跌为0

#### InnoDB刷脏页的控制策略

需要正确告诉InnoDB所在主机的IO能力，使用innodb_io_capacity，建议设置成磁盘的IOPS

InnoDB的刷盘速度参考两个因素
- 脏页比例
- redo log写盘速度

InnoDB会根据这两个因素先单独算出两个数字

参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例M，算出一个范围在0到100之间的数字

InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值假设为N，InnoDB会根据N算出一个范围在0到100间的数字（N越大，算出来的值越大）

然后，根据f1(M)和f2(N)算的的两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capcity定义的能力乘以R%来控制刷脏页的速度

{% asset_img 14.png %}

一旦一个查询请求需要在执行过程中先flush掉一个脏页时，如果这个数据页旁边的数据页刚好是脏页，就会把这个邻居也带着一起刷掉；而且这个逻辑还可以继续蔓延。innodb_flush_neighbors就是用来控制这个行为的，值为1的时候会有上述机制

上述策略在机械硬盘是有意义的，可以减少很多随机IO，如果是SSD建议关闭（8.0默认为0）

### 表数据删除

表数据既可以存在共享表空间里，也可以是单独的文件。由参数innodb_file_per_table控制的，OFF表示表的数据放在系统共享表空间，也就是和数据字典放在一起；ON表示每个InnoDB表数据存储在一个已.ibd为后缀的文件中（默认ON）

建议设置为ON。一个表单独存储更容易管理，而且如果放在共享表空间中，及时表删掉了，空间也是不会回收的

在删除整个表的时候，可以使用drop table回收表空间。但是如果删除某些行，表中的数据被删除了，但是表空间却没有被回收

#### 数据删除流程

假设要删掉一个记录，InnoDB只会把这个记录标记为删除，如果之后在相同位置插入一个新纪录时，可能会复用这个位置。磁盘文件的大小不会缩小

如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了

数据页的复用和记录的复用是不同的

记录的复用，只限于符合范围条件的数据
当整个页从B+树里摘掉之后，可以复用到任何位置

如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用

如果我们用delete命令把整个表的数据删除，结果就是所有的数据页都会被标记为可复用，但磁盘上文件不会变小

这些可以复用，而没有被使用的空间，看起来就像是“空洞”

不只是删除数据会造成空洞，插入数据也会

如果数据是随机插入的，可能造成索引的数据页分裂

{% asset_img 15.png %}

另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新的值，也可能会造成空洞

经过大量增删改的表，都是可能存在空洞的。重建表可以把这些空洞去掉，达到收缩表空间的目的

#### 重建表

alter table
新建一个相同结构的表，按照主键ID递增顺序一行一行读出来再插入到新表
在整个DDL过程中，原表不能有更新

{% asset_img 16.png %}

Oneline DDL：
{% asset_img 17.png %}

### COUNT * 

为什么InnoDB不合MyISAM一样，也把数字存起来
由于MVCC的原因，InnoDB表应该返回多少行是不确定的，每一行记录都要判断自己是否对这个会话可见

MySQL优化器会找到最小的索引树来遍历，尽量减少扫描的数据量

show table status 中的 TABLE_ROWS 是通过采样来估算的，误差可能达到40%~50%

### ORDER BY

#### 全字段排序

explain之后，Extra中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort buffer

```
select city, name, age from t where city = 'A' order by name limit 1000;
```

执行流程：
1. 初始化sort buffer，确定放入需要查询的字段
2. 从索引找到第一个满足查询条件的id
3. 到主键索引取出整行，取查询字段的值，存入sort buffer
4. 从索引中取下一个记录的id
5. 重复3、4步骤，直到不满足查询条件为止
6. 对sort_buffer中的数据按照排序条件做快速排序
7. 按照排序结果取前N行返回

{% asset_img 18.jpg %}

其中的排序动作，可能在内存中完成，也可能需要使用外部排序，取决于排序所需的内存和参数sort_buffer_size

sort_buffer_size: sort_buffer的大小

#### rowid排序

max_length_for_sort_data: 如果单行的长度超过这个值，MySQL会认为单行太大，需要换一种算法
新的算法放入sort_buffer的字段，只有需要排序的字段和主键id

执行流程：
1. 初始化sort buffer，确定放入排序字段和主键字段
2. 从索引找到第一个满足查询条件的id
3. 到主键索引中取出郑航，取排序字段和主键的值，存入sort buffer
4. 从索引中取下一个记录的id
5. 重复3、4步骤，直到不满足查询条件为止
6. 对sort buffer中的数据按照排序字段排序
7. 遍历排序结果，取前N行，并按照id的值回到原表中取出查询字段返回

{% asset_img 19.jpg %}

rowid排序多访问了一次主键索引



如果可以保证从索引上取出的行，天然是按照排序字段排好序的话，就不需要排序操作了

有时，可以通过建立联合索引解决

{% asset_img 20.png %}

执行流程：
1. 从索引找到第一个满足查询条件的id
2. 到主键索引中根据id取出整行，作为结果集的一部分直接返回
3. 从索引中取下一个主键id
4. 重复2、3步骤，直到查到第N条记录，或者当不满足查询条件时循环结束

{% asset_img 21.jpg %}

此时，explain中的extra为"Using index condition"

可以利用覆盖索引，使过程更加简化
eg 可以创建一个city、name、age的联合索引，这样的话就不需要回表了

{% asset_img 22.jpg %}

此时，explain中的extra为“Using index”


